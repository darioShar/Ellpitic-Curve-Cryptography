#pragma once
#include <stdarg.h>
#include <stdio.h>
#include <time.h>
#include <mpir.h>
#include <string>
#include <vector>
#include <ctime>
#include <algorithm>
#include <unordered_set>
#include "EllPoint.h"
#include "Poly.h"
//#include "ZpZ.h"

#define BSGS_MEMORY 3*1024*1024*1024
#define MAX_RANDOM_BITCOUNT 512

/*Elliptic Curve*/
class EllCurve
{
public:
	/*Constructs a new elliptic curve with its generator set to 0*/
	EllCurve();
	EllCurve(const ECParam& param);
	EllCurve(ECParam&& param);
	EllCurve(const EllCurve& curve);
	~EllCurve();

	/*Returns i*P where P is the generator in use*/
	EllPoint operator[](const mpz_t& i) const;

	/*Returns i*P where P is the generator in use*/
	EllPoint operator[](mpir_ui i) const;

	/*Sets new curve parameters, finds new generator and then returns true 
	if parameters are usable (i.e no problems such as curve singularity or 
	weak choice of p (?)). If param order is null, finds curve order. 
	Returns false otherwise and resets curve parameters.*/
	bool setECParam(ECParam&& param, bool verbose = false);
	bool setECParam(const ECParam& param, bool verbose = false);

	/*Returns the parameters of the curve in use*/
	const ECParam& getECParam() const;

	/*Returns generator in use*/
	const EllPoint& getGen() const;

	/* Sets a new generator. Returns true if valid order and point on curve, false otherwise*/
	bool setGen(const ECCoord& coord, const mpz_t& order);

	/*Finds a new generator by efficiently randomly finding a new point on
	the elliptic curve in use.*/
	void findNewGen();

	/* Finds order of the generator*/
	void findGenOrder();

	/*Returns order of the subgroup generated by generator. For now, since order is prime, same as curve order.*/
	const mpz_t& getGenOrder() const;

	/*Finds a point on the elliptic curve in use, by random trials.
	Because this can be very slow for large Fp, user can specify a time threshold
	in ms after which the function will fail, returning false. 0 means no threshold,
	which may lead to the program freezing.
	On success returns true with found point stored in dest*/
	bool getRandomPointRandomTrials(EllPoint& dest, mpir_ui time_threshold_ms = ~0);

	/*Returns kP with random k which will then be stored in random_k parameter*/
	EllPoint getRandomPoint(mpz_t& random_k);

	/* Finds new random parameter A, B and P for the curve. If an argument
	P is passed, the most probable prime greater than P will be used and
	new A and B will be found accordingly. Gen point is reset to neutral point*/
	void setRandomParam(mpir_ui p = 0, bool findOrder = false, bool verbose = false);
	void setRandomParam(const mpz_t p = NULL, bool findOrder = false, bool verbose = false);

	/*Finds curve order using naive formula. Result will be stored in internal ECParam.order*/
	void findCurveOrderNaive();

	/*Finds curve order using Hasse Theorem naively. Result will be stored in internal ECParam.order*/
	void findCurveOrderHasseNaive();

	/*Finds curve order using Hasse Theorem and baby-steps giant-steps. Result will be stored in internal ECParam.order*/
	bool findCurveOrderHasseBSGS();

	/*Finds curve order using basic Schoof algorithm. Result will be stored in internal ECParam.order*/
	void findCurveOrderSchoof(); // TODO

	/*Finds curve order using improved Schoof algorithm (Schoof-Elkies-Atkin aka SEA). Result will be stored in internal ECParam.order*/
	void findCurveOrderSEA(); // TODO

	/*Returns curve order.*/
	const mpz_t& getCurveOrder() const;

	/*Finds k satisfying K = k*P where P is the generator in use.
	Cracking the discrete logarithm problem with baby step giant step method.
	max_memory_usage is the maximum amount of memory the function
	will be able to use (default being BSGS_MEMEORY bytes).
	Returns true if found before time threshold, false otherwise*/
	bool crackDiscreteLogBSGS(mpz_t& k, const EllPoint& K, mpir_ui time_threshold_ms = -1, mpir_ui max_memory_usage = BSGS_MEMORY) const;

	/*Finds k satisfying K = k*P where P is the generator in use.
	Cracking the discrete logarithm problem naively.
	Returns true if found before time threshold, false otherwise*/
	bool crackDiscreteLogNaive(mpz_t& k, const EllPoint& K ,mpir_ui time_threshold_ms = -1) const;	

	/*Prints the elliptic curve parameters with its name if given, and the generator in use*/
	void print(const char* name = "", bool printGen = false) const;

	// Finds exact order of G from k, knowing that k * G = 0.
	// k is set to the lowest number such that k * G = 0; assumes sqrt(k) can be stored in mpir_ui
	void static find_exact_order(mpz_t& k, const EllPoint& G);

	// pre compute j*gen for 0<= j <= m
	void static pre_compute_bsgs(std::unordered_set<ECPair, BSGSHasher>& data, const EllPoint& gen, mpir_ui m);

	// find k != 0 such that k * G = K using baby step giant step. m is such that it is possible to write k = (am + b), 0<= a,b <= m.
	// data must hold j*gen for 0<= j <= m
	void static find_k_bsgs(mpz_t& k, const std::unordered_set<ECPair, BSGSHasher>& data, const EllPoint& gen, const EllPoint& K, mpir_ui m);

private :

	EllPoint				m_gen; // subgroup generator
	mpz_t					m_genOrder;
	ECParam					m_param;
};
